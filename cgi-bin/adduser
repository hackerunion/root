#!/usr/bin/env node

var MAX_URI = 128;
var MAX_INFO = 64;
var MAX_USERNAME = 16;
var MIN_USERNAME = 1;
var MIN_PASSWORD = 5;

// ensure that all paths are relative to this file's actual location
process.chdir(__dirname);

var _ = require('lodash');
var fs = require('fs');
var url = require('url');
var crypt = require('crypt3');
var child_process = require('child_process');

var body = require('../lib/js/body');

function response(code, value) {
  console.log("Status: " + code);
  console.log("Content-Type: application/json")
  console.log("\n");
  
  if (value) {
    console.log(value);
    //console.log(JSON.stringify(value));
  }

  return false;
};

function nullify(v) {
  if (!v || !v.length) {
    return null;
  }

  return v;
};

function etcPasswd() {
  try {
    return _.sortBy(require('../etc/passwd.json'), function (x) { return -1 * x.uid; });
  } catch(e) {
    return response(500, 'Unable to read password file');
  }
};

function etcGroup() {
  try {
    return _.sortBy(require('../etc/group.json'), function (x) { return -1 * x.gid; });
  } catch(e) {
    return response(500, 'Unable to read group file');
  }
};

function sanitize(qs) {
  // quick validation
  if (!qs.username || !qs.password) {
    return response(500, 'Password and username are required');
  }

  if (qs.username.length > MAX_USERNAME) {
    return response(500, 'Username is too long');
  }
  
  if (qs.username.length < MIN_USERNAME) {
    return response(500, 'Username is too short');
  }

  qs.username = qs.username.toLowerCase();

  if (qs.password.length < MIN_PASSWORD) {
    return response(500, 'Password is too short');
  }

  if (qs.info.length > MAX_INFO) {
    return response(500, 'Notes are too long');
  }

  if (qs.uri) {
    if (qs.uri.length > MAX_URI) {
      return response(500, 'URI is too long');
    }

    var parsed = url.parse(qs.uri);

    if (!parsed.host || -1 == ['http:', 'https:'].indexOf(parsed.protocol)) {
      return response(500, 'Invalid URI');
    }

    qs.uri = url.format(parsed);
  }

  if (qs.service && !qs.uri) {
    return response(500, 'Services must include a URI');
  }

  return true;
};

// this is included for convenience
if (!/post/i.test(process.env.REQUEST_METHOD)) {
  var html="";
  
  html += '<html>';
  html += '<body>';
  html += '<h1>Add a User</h1>';
  html += '<hr />';
  html += '<form method="post">';
  html += '  <label for="username">Username:</label> <input type="text" name="username" /> <br />';
  html += '  <label for="password">Password:</label> <input type="password" name="password" /> <br />';
  html += '  <label for="info">Note:</label> <input type="text" name="info" /> <br />';
  html += '  <label for="service">Is Service:</label> <input type="checkbox" name="service" /> <br />';
  html += '  <label for="uri">URI (optional):</label> <input type="text" name="uri" /> <br />';
  html += '  <input type="submit" value="Create User" />';
  html += '</form>';
  html += '</body>';
  html += '</html>';
 
  return console.log("Status: 200\nContent-Type: text/html\n\n" + html);
}

body.parse(process.stdin, function(err, qs) {
  var uid;
  var gid;
  var hash;
  var users;
  var groups;

  if (err) {
    return response(500, err);
  }
  
  if (!sanitize(qs)) return;
  if (!(users = etcPasswd())) return;
  if (!(groups = etcGroup())) return;

  if (_.findWhere(users, { 'username': qs.username })) {
    return response(500, 'Username already in use');
  }

  if (_.findWhere(groups, { 'group': qs.username })) {
    return response(500, 'Username already in use (group)');
  }
  
  // select next sequential uid and gid
  uid = parseInt(users[0].uid) + 1 + "";
  gid = parseInt(groups[0].gid) + 1 + "";

  fs.writeFile('../etc/group.json', JSON.stringify(groups.concat({
    'group': qs.username,
    'gid': gid,
    'users': []
  })));

  fs.writeFile('../etc/passwd.json', JSON.stringify(users.concat({
    'username': qs.username,
    'password': crypt(qs.password),
    'uid': uid,
    'gid': gid,
    'info': qs.info || '',
    'service': !!qs.service,
    'uri': qs.uri || ''
  })));
  
  var sync = child_process.spawn('../sbin/sync', [], {
    'cwd': process.cwd(),
    'uid': 0,
    'gid': 0
  });
  
  sync.on('close', function (code) {
    if (code) {
      return response(500, 'Sync error (' + code + ')');
    }

    response(200);
  });
});
